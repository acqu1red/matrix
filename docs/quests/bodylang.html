<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>–Ø–∑—ã–∫ —Ç–µ–ª–∞ - –§–æ—Ä–º—É–ª–∞ Quests</title>
  <link rel="stylesheet" href="quests-black-white.css">
  <style>
    /* –°–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã–µ —Å—Ç–∏–ª–∏ –¥–ª—è –∫–≤–µ—Å—Ç–∞ "–Ø–∑—ã–∫ —Ç–µ–ª–∞" */
    .quest-container {
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
    }

    /* –°–∫—Ä—ã–≤–∞–µ–º —ç–ª–µ–º–µ–Ω—Ç—ã —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –≤–∏–¥–µ–æ –≤ —Ñ–∞–∑–µ —ç–º–æ—Ü–∏–π */
    #facePhase .video-controls {
      display: none !important;
    }

    #facePhase .video-player {
      pointer-events: none;
    }

    .phase-indicator {
      display: flex;
      justify-content: center;
      margin-bottom: 30px;
      gap: 8px; /* –î–æ–±–∞–≤–∏–º –Ω–µ–±–æ–ª—å—à–æ–π –æ—Ç—Å—Ç—É–ø */
    }

    .phase-badge {
      background: var(--glass);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      padding: 8px 12px; /* –ù–µ–º–Ω–æ–≥–æ –∏–∑–º–µ–Ω–∏–º –ø–∞–¥–¥–∏–Ω–≥ */
      font-size: 12px; /* –£–º–µ–Ω—å—à–∏–º —à—Ä–∏—Ñ—Ç –¥–ª—è 5 —ç—Ç–∞–ø–æ–≤ */
      color: var(--text-muted);
    }

    .phase-badge.active {
      background: var(--glow1);
      color: var(--bg0);
      font-weight: 600;
    }

    /* –í–∏–¥–µ–æ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä */
    .video-container {
      background: var(--glass);
      border-radius: var(--radius);
      padding: 20px;
      margin-bottom: 30px;
      text-align: center;
    }

    .video-player {
      width: 100%;
      max-width: 400px;
      border-radius: var(--radius-sm);
      margin-bottom: 16px;
    }

    .video-controls {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 12px;
      margin-bottom: 16px;
    }

    .play-btn {
      background: var(--glow1);
      color: var(--bg0);
      border: none;
      border-radius: 50%;
      width: 48px;
      height: 48px;
      font-size: 20px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
    }

    .play-btn:hover {
      transform: scale(1.1);
      box-shadow: 0 0 20px rgba(102, 247, 213, 0.4);
    }

    .progress-bar {
      flex: 1;
      max-width: 300px;
      height: 6px;
      background: var(--glass-strong);
      border-radius: 3px;
      overflow: hidden;
    }

    .progress-fill {
      height: 100%;
      background: var(--glow1);
      width: 0%;
      transition: width 0.1s ease;
    }

    .video-annotation {
      background: linear-gradient(135deg, rgba(102, 247, 213, 0.1), rgba(102, 247, 213, 0.05));
      border: 1px solid rgba(102, 247, 213, 0.2);
      border-radius: var(--radius-sm);
      padding: 16px;
      margin-top: 16px;
      font-size: 14px;
      color: var(--text);
    }

    /* –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä –¥–ª—è –∞–Ω–∏–º–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –ª–∏—Ü */
    .face-container {
      background: var(--glass);
      border-radius: var(--radius);
      padding: 30px;
      margin-bottom: 30px;
      text-align: center;
      min-height: 400px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

    .face-sprite {
      width: 256px;
      height: 256px;
      background-size: calc(var(--cols) * 100%) calc(var(--rows) * 100%);
      image-rendering: auto;
      border-radius: 12px;
      border: 2px solid var(--border);
      margin-bottom: 20px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    }

    .face-instruction {
      font-size: 16px;
      color: var(--text);
      margin-bottom: 24px;
      font-weight: 500;
    }

    /* –í–∞—Ä–∏–∞–Ω—Ç—ã –æ—Ç–≤–µ—Ç–æ–≤ */
    .answer-options {
      display: grid;
      grid-template-columns: 1fr;
      gap: 12px;
      margin-top: 20px;
    }

    .answer-option {
      background: var(--glass);
      border: 2px solid var(--border);
      border-radius: var(--radius-sm);
      padding: 16px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-align: center;
      font-size: 16px;
      font-weight: 500;
    }

    .answer-option:hover {
      border-color: var(--glow1);
      background: var(--glass-strong);
      transform: translateY(-2px);
    }

    .answer-option.correct {
      background: linear-gradient(135deg, var(--success), #22C55E);
      color: white;
      border-color: var(--success);
    }

    .answer-option.incorrect {
      background: linear-gradient(135deg, var(--warning), #F59E0B);
      color: white;
      border-color: var(--warning);
    }

    /* –°—á–µ—Ç—á–∏–∫ –ø–æ–ø—ã—Ç–æ–∫ */
    .attempts-counter {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      margin-bottom: 20px;
    }

    .attempts-text {
      font-size: 14px;
      color: var(--text-muted);
    }

    .attempts-dots {
      display: flex;
      gap: 4px;
    }

    .attempt-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--border);
      transition: all 0.3s ease;
    }

    .attempt-dot.used {
      background: var(--warning);
    }

    /* –ö–Ω–æ–ø–∫–∏ –Ω–∞–≤–∏–≥–∞—Ü–∏–∏ */
    .quest-controls {
      display: flex;
      gap: 12px;
      justify-content: center;
      margin-top: 20px;
    }

    .btn-back {
      background: var(--glass);
      border: 1px solid var(--border);
      color: var(--text);
      padding: 12px 24px;
      border-radius: var(--radius-sm);
      cursor: pointer;
      transition: all 0.3s ease;
      text-decoration: none;
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }

    .btn-back:hover {
      background: var(--glass-strong);
      border-color: var(--border-strong);
    }

    /* –ú–æ–¥–∞–ª –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è */
    .quest-complete {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s ease;
    }

    .quest-complete.show {
      opacity: 1;
      visibility: visible;
    }

    .quest-complete-content {
      background: var(--bg1);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 40px;
      text-align: center;
      max-width: 400px;
      width: 90%;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
    }

    .quest-complete-icon {
      font-size: 64px;
      margin-bottom: 20px;
    }

    .quest-complete-title {
      font-size: 24px;
      font-weight: 700;
      color: var(--glow1);
      margin-bottom: 16px;
    }

    .quest-complete-description {
      color: var(--text-muted);
      margin-bottom: 24px;
      line-height: 1.5;
    }

    .quest-rewards {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 16px;
      margin-bottom: 24px;
    }

    .reward-item {
      background: var(--glass);
      border-radius: var(--radius-sm);
      padding: 16px;
      text-align: center;
    }

    .reward-amount {
      font-size: 24px;
      font-weight: 700;
      color: var(--glow1);
      margin-bottom: 4px;
    }

    .reward-label {
      font-size: 12px;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .btn-close {
      background: var(--glow1);
      color: var(--bg0);
      border: none;
      border-radius: var(--radius-sm);
      padding: 12px 24px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .btn-close:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(102, 247, 213, 0.3);
    }

    /* –ê–¥–∞–ø—Ç–∏–≤–Ω–æ—Å—Ç—å */
    @media (max-width: 768px) {
      .quest-container {
        padding: 16px;
      }
      
      .face-sprite {
        width: 200px;
        height: 200px;
      }
      
      .answer-options {
        grid-template-columns: 1fr;
      }
    }

    /* –°—Ç–∏–ª–∏ –¥–ª—è –Ω–æ–≤—ã—Ö —ç—Ç–∞–ø–æ–≤ */

    /* –≠—Ç–∞–ø 3: –ü–æ–π–º–∞–π —Å–∏–≥–Ω–∞–ª */
    .signal-catch-container {
      background: var(--glass);
      border-radius: var(--radius);
      padding: 20px;
      margin-bottom: 30px;
      text-align: center;
      height: 500px; /* –§–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –≤—ã—Å–æ—Ç–∞ –¥–ª—è —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç–∏ */
      display: flex;
      flex-direction: column;
      justify-content: space-between;
    }

    .signal-timer-bar {
      width: 100%;
      height: 8px;
      background: var(--glass-strong);
      border-radius: 4px;
      overflow: hidden;
    }

    .signal-timer-fill {
      width: 100%;
      height: 100%;
      background: var(--glow1);
      transition: width 1s linear;
    }
    
    .mannequin-container {
      flex-grow: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      cursor: pointer;
    }

    .mannequin-svg {
      width: 200px;
      height: 300px;
    }

    .mannequin-svg path, .mannequin-svg circle {
      stroke: var(--text);
      stroke-width: 4;
      stroke-linecap: round;
      fill: none;
      transition: transform 0.3s ease-in-out;
    }

    .signal-hints {
      display: flex;
      justify-content: center;
      gap: 10px;
    }

    .signal-hint-badge {
      background: var(--glass-strong);
      border: 1px solid var(--border);
      padding: 6px 12px;
      border-radius: var(--radius-sm);
      color: var(--text-muted);
      font-size: 12px;
    }
    
    /* –≠—Ç–∞–ø 4: –°–æ–±–µ—Ä–∏ –ª–∏—Ü–æ */
    .face-build-container {
      background: var(--glass);
      border-radius: var(--radius);
      padding: 20px;
      margin-bottom: 30px;
      text-align: center;
    }

    .face-build-svg {
      width: 200px;
      height: 200px;
      margin: 20px auto;
      display: block;
    }

    .face-controls {
      display: flex;
      flex-direction: column;
      gap: 20px;
      padding: 0 20px;
    }
    .control-group {
      text-align: left;
    }
    .control-group label {
      display: block;
      margin-bottom: 8px;
      color: var(--text-muted);
    }
    .control-group input[type="range"] {
      width: 100%;
    }

    /* –≠—Ç–∞–ø 5: –ö–æ–º–ø–∞—Å –¥–∏—Å—Ç–∞–Ω—Ü–∏–∏ */
    .distance-compass-container {
      background: var(--glass);
      border-radius: var(--radius);
      padding: 20px;
      margin-bottom: 30px;
      text-align: center;
    }

    .proxemics-stage {
      width: 100%;
      height: 400px;
      background: var(--glass-strong);
      border-radius: var(--radius-sm);
      position: relative;
      overflow: hidden;
      cursor: grab;
    }
    
    .proxemics-zone {
      position: absolute;
      border-radius: 50%;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      border: 1px dashed var(--border);
    }
    .proxemics-avatar {
      position: absolute;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--bg0);
      font-weight: bold;
      user-select: none;
    }
    .avatar-user {
      background: var(--glow1);
      cursor: grab;
    }
    .avatar-npc {
      background: var(--text-muted);
    }
    
    /* Custom Modal for results */
    .result-modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(2, 0, 16, 0.9);
        backdrop-filter: blur(15px);
        z-index: 2000;
        display: flex;
        align-items: center;
        justify-content: center;
        opacity: 0;
        transition: opacity 0.3s ease;
        pointer-events: none;
    }
    .result-modal-overlay.show {
        opacity: 1;
        pointer-events: all;
    }
    .result-modal {
        background: var(--bg-card);
        padding: 30px;
        border-radius: var(--radius);
        text-align: center;
        transform: scale(0.9);
        transition: transform 0.3s ease;
    }
    .result-modal-overlay.show .result-modal {
        transform: scale(1);
    }
    .result-modal-title {
        font-size: 24px;
        font-weight: 700;
        margin-bottom: 12px;
        color: var(--glow1);
    }
    .result-modal-text {
        color: var(--text-secondary);
        margin-bottom: 24px;
    }
    .result-modal-button {
        background: var(--glow1);
        color: var(--bg0);
        border: none;
        border-radius: var(--radius-sm);
        padding: 12px 24px;
        font-weight: 600;
        cursor: pointer;
    }
    .result-modal-choices {
        display: flex;
        flex-direction: column;
        gap: 10px;
        margin-top: 20px;
    }
  </style>
</head>
<body>
  <div class="quest-container">
    <!-- –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä —Ñ–∞–∑—ã -->
    <div class="phase-indicator">
      <div class="phase-badge" id="phase1Badge">–≠—Ç–∞–ø 1: –õ–æ–∂—å</div>
      <div class="phase-badge" id="phase2Badge">–≠—Ç–∞–ø 2: –≠–º–æ—Ü–∏–∏</div>
      <div class="phase-badge" id="phase3Badge">–≠—Ç–∞–ø 3: –°–∏–≥–Ω–∞–ª—ã</div>
      <div class="phase-badge" id="phase4Badge">–≠—Ç–∞–ø 4: –õ–∏—Ü–æ</div>
      <div class="phase-badge" id="phase5Badge">–≠—Ç–∞–ø 5: –î–∏—Å—Ç–∞–Ω—Ü–∏—è</div>
    </div>

    <!-- –≠—Ç–∞–ø 1: –í–∏–¥–µ–æ –¥–æ–ø—Ä–æ—Å (–õ–æ–∂—å) -->
    <div id="lie-detection-phase" class="video-container">
      <h3>–ê–Ω–∞–ª–∏–∑ —è–∑—ã–∫–∞ —Ç–µ–ª–∞ –≤ –≤–∏–¥–µ–æ</h3>
      <p style="color: var(--text-muted); margin-bottom: 20px;">
        –ü–æ—Å–º–æ—Ç—Ä–∏—Ç–µ –≤–∏–¥–µ–æ –∏ –æ–ø—Ä–µ–¥–µ–ª–∏—Ç–µ, –∫–∞–∫–æ–µ –Ω–µ–≤–µ—Ä–±–∞–ª—å–Ω–æ–µ –ø–æ–≤–µ–¥–µ–Ω–∏–µ –¥–µ–º–æ–Ω—Å—Ç—Ä–∏—Ä—É–µ—Ç —á–µ–ª–æ–≤–µ–∫.
      </p>
      
      <video id="lieVideoPlayer" class="video-player" preload="metadata">
        <source src="" type="video/mp4">
        –í–∞—à –±—Ä–∞—É–∑–µ—Ä –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –≤–∏–¥–µ–æ.
      </video>
      
      <div class="video-controls">
        <button class="play-btn" id="liePlayBtn">‚ñ∂Ô∏è</button>
        <div class="progress-bar">
          <div class="progress-fill" id="lieProgressFill"></div>
        </div>
      </div>
      
      <div class="video-annotation">
        <strong>üí° –ü–æ–¥—Å–∫–∞–∑–∫–∞:</strong> –í –∑–∞–∫—Ä—ã—Ç–æ–º –∫–∞–Ω–∞–ª–µ —Ç—ã –º–æ–∂–µ—à—å —É–∑–Ω–∞—Ç—å –æ —è–∑—ã–∫–µ —Ç–µ–ª–∞ –Ω–∞–º–Ω–æ–≥–æ –±–æ–ª—å—à–µ.
      </div>
      
      <div class="attempts-counter">
        <span class="attempts-text">–ü–æ–ø—ã—Ç–∫–∏:</span>
        <div class="attempts-dots" id="lieAttemptsDots">
          <div class="attempt-dot"></div>
          <div class="attempt-dot"></div>
          <div class="attempt-dot"></div>
        </div>
      </div>
      
      <div class="answer-options" id="lieOptions">
        <!-- –í–∞—Ä–∏–∞–Ω—Ç—ã –æ—Ç–≤–µ—Ç–æ–≤ –±—É–¥—É—Ç –¥–æ–±–∞–≤–ª–µ–Ω—ã –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏ -->
      </div>
    </div>

    <!-- –≠—Ç–∞–ø 2: –ê–Ω–∞–ª–∏–∑ —ç–º–æ—Ü–∏–π -->
    <div id="emotion-detection-phase" class="video-container" style="display: none;">
      <h3>–ê–Ω–∞–ª–∏–∑ —ç–º–æ—Ü–∏–π</h3>
      <p style="color: var(--text-muted); margin-bottom: 20px;">
        –ü–æ—Å–º–æ—Ç—Ä–∏—Ç–µ –≤–∏–¥–µ–æ –∏ –æ–ø—Ä–µ–¥–µ–ª–∏—Ç–µ —ç–º–æ—Ü–∏—é –ø–µ—Ä—Å–æ–Ω–∞–∂–∞.
      </p>
      
      <div class="video-frame">
        <video id="emotionVideoPlayer" class="video-player" preload="metadata" muted playsInline loop>
          <source src="" type="video/mp4">
          –í–∞—à –±—Ä–∞—É–∑–µ—Ä –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –≤–∏–¥–µ–æ.
        </video>
      </div>
      
      <div class="attempts-counter">
        <span class="attempts-text">–ü–æ–ø—ã—Ç–∫–∏:</span>
        <div class="attempts-dots" id="emotionAttemptsDots">
          <div class="attempt-dot"></div>
          <div class="attempt-dot"></div>
          <div class="attempt-dot"></div>
        </div>
      </div>
      
      <div class="answer-options" id="emotionOptions">
        <!-- –í–∞—Ä–∏–∞–Ω—Ç—ã –æ—Ç–≤–µ—Ç–æ–≤ –±—É–¥—É—Ç –¥–æ–±–∞–≤–ª–µ–Ω—ã –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏ -->
      </div>
    </div>

    <!-- –≠—Ç–∞–ø 3: –ü–æ–π–º–∞–π —Å–∏–≥–Ω–∞–ª -->
    <div id="signal-catch-phase" class="signal-catch-container" style="display: none;">
      <h3>–≠—Ç–∞–ø 3: –ü–æ–π–º–∞–π —Å–∏–≥–Ω–∞–ª</h3>
      <p>–õ–æ–≤–∏ –º–æ–º–µ–Ω—Ç! –£–≤–∏–¥–µ–ª –Ω–µ–æ–±—ã—á–Ω–æ–µ –¥–≤–∏–∂–µ–Ω–∏–µ ‚Äî —Ç–∞–ø–Ω–∏. –ü–æ—Å–ª–µ ‚Äî –Ω–∞–∑–æ–≤–∏ —Å–∏–≥–Ω–∞–ª.</p>
      <div class="signal-timer-bar"><div class="signal-timer-fill"></div></div>
      <div class="mannequin-container" id="mannequinContainer">
        <svg id="mannequinSvg" class="mannequin-svg" viewBox="0 0 200 300">
            <g id="manGroup">
              <!-- –ì–æ–ª–æ–≤–∞ -->
              <circle id="head" cx="100" cy="40" r="20"/>
              <!-- –¢–µ–ª–æ -->
              <path id="torso" d="M 100 60 L 100 160"/>
              <!-- –†—É–∫–∏ -->
              <path id="left_arm" d="M 100 80 L 60 140 L 40 200"/>
              <path id="right_arm" d="M 100 80 L 140 140 L 160 200"/>
              <!-- –ù–æ–≥–∏ -->
              <path id="left_leg" d="M 100 160 L 70 230 L 60 300"/>
              <path id="right_leg" d="M 100 160 L 130 230 L 140 300"/>
            </g>
        </svg>
      </div>
      <div class="signal-hints">
        <span class="signal-hint-badge">—Å–∞–º–æ—É—Å–ø–æ–∫–æ–µ–Ω–∏–µ</span>
        <span class="signal-hint-badge">–±–∞—Ä—å–µ—Ä</span>
        <span class="signal-hint-badge">–¥–æ–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ</span>
      </div>
    </div>

    <!-- –≠—Ç–∞–ø 4: –°–æ–±–µ—Ä–∏ –ª–∏—Ü–æ -->
    <div id="face-build-phase" class="face-build-container" style="display: none;">
        <h3>–≠—Ç–∞–ø 4: –°–æ–±–µ—Ä–∏ –ª–∏—Ü–æ</h3>
        <p>–ü–æ–¥–±–µ—Ä–∏ –º–∏–º–∏–∫—É –∫ –ø–æ–¥—Å–∫–∞–∑–∫–µ. –ì–æ—Ç–æ–≤? –ñ–º–∏ "–û—Ü–µ–Ω–∏—Ç—å" ‚Äî –ø–æ—Å–º–æ—Ç—Ä–∏–º, —á—Ç–æ —Å—á–∏—Ç–∞–ª –º–æ–∑–≥.</p>
        <div id="faceBuildTarget" class="face-instruction"></div>
        <svg id="faceBuildSvg" class="face-build-svg" viewBox="0 0 200 200">
            <!-- Face shape -->
            <path d="M 50 20 C 20 20, 10 80, 20 120 C 30 180, 170 180, 180 120 C 190 80, 180 20, 150 20 Z" fill="#222" stroke="var(--text)" stroke-width="2"/>
            <!-- Eyes -->
            <path id="leftEye" d="M 60 70 Q 80 60, 100 70" stroke="var(--text)" stroke-width="3" fill="none"/>
            <path id="rightEye" d="M 120 70 Q 140 60, 160 70" stroke="var(--text)" stroke-width="3" fill="none"/>
            <!-- Eyebrows -->
            <path id="leftEyebrow" d="M 50 50 Q 80 40, 110 50" stroke="var(--text)" stroke-width="4" fill="none"/>
            <path id="rightEyebrow" d="M 110 50 Q 140 40, 170 50" stroke="var(--text)" stroke-width="4" fill="none"/>
            <!-- Mouth -->
            <path id="mouth" d="M 70 140 Q 100 150, 130 140" stroke="var(--text)" stroke-width="3" fill="none"/>
        </svg>
        <div class="face-controls">
            <div class="control-group">
                <label for="browsSlider">–ù–∞–∫–ª–æ–Ω –±—Ä–æ–≤–µ–π</label>
                <input type="range" id="browsSlider" min="-1" max="1" value="0" step="0.1">
            </div>
            <div class="control-group">
                <label for="eyesSlider">–û—Ç–∫—Ä—ã—Ç–æ—Å—Ç—å –≥–ª–∞–∑</label>
                <input type="range" id="eyesSlider" min="-1" max="1" value="0" step="0.1">
            </div>
            <div class="control-group">
                <label for="mouthSlider">–£–ª—ã–±–∫–∞ / –•–º—É—Ä–æ—Å—Ç—å</label>
                <input type="range" id="mouthSlider" min="-1" max="1" value="0" step="0.1">
            </div>
        </div>
        <button id="evaluateFaceBtn" class="btn-next">–û—Ü–µ–Ω–∏—Ç—å</button>
    </div>

    <!-- –≠—Ç–∞–ø 5: –ö–æ–º–ø–∞—Å –¥–∏—Å—Ç–∞–Ω—Ü–∏–∏ -->
    <div id="distance-compass-phase" class="distance-compass-container" style="display: none;">
      <h3>–≠—Ç–∞–ø 5: –ö–æ–º–ø–∞—Å –¥–∏—Å—Ç–∞–Ω—Ü–∏–∏</h3>
      <p>–†–∞—Å—Å—Ç–∞–≤—å —Å–µ–±—è —Ç–∞–∫, —á—Ç–æ–±—ã –±—ã–ª–æ –∫–æ–º—Ñ–æ—Ä—Ç–Ω–æ –æ–±–æ–∏–º. –ü–æ–≤–µ—Ä–Ω–∏ –∫–æ—Ä–ø—É—Å ‚Äî –Ω–µ —Ç–∞—Ä–∞–Ω–æ–º, –∞ –¥—Ä—É–∂–µ–ª—é–±–Ω–æ.</p>
      <div id="proxemicsScenario" class="face-instruction"></div>
      <div id="proxemicsStage" class="proxemics-stage">
          <!-- –ó–æ–Ω—ã -->
          <div class="proxemics-zone" style="width: 800px; height: 800px;"></div>
          <div class="proxemics-zone" style="width: 400px; height: 400px;"></div>
          <div class="proxemics-zone" style="width: 150px; height: 150px;"></div>
          <!-- –ê–≤–∞—Ç–∞—Ä—ã -->
          <div id="npcAvatar" class="proxemics-avatar avatar-npc">C</div>
          <div id="userAvatar" class="proxemics-avatar avatar-user">–¢—ã</div>
      </div>
      <button id="checkDistanceBtn" class="btn-next">–ü—Ä–æ–≤–µ—Ä–∏—Ç—å</button>
    </div>

    <!-- –ö–Ω–æ–ø–∫–∏ –Ω–∞–≤–∏–≥–∞—Ü–∏–∏ -->
    <div class="quest-controls">
      <a href="../quests.html" class="btn-back">‚Üê –ù–∞–∑–∞–¥ –∫ –∫–≤–µ—Å—Ç–∞–º</a>
    </div>

    <!-- Result Modal -->
    <div id="resultModal" class="result-modal-overlay">
        <div class="result-modal">
            <h3 id="resultModalTitle" class="result-modal-title"></h3>
            <p id="resultModalText" class="result-modal-text"></p>
            <div id="resultModalChoices" class="result-modal-choices"></div>
            <button id="resultModalButton" class="result-modal-button">–î–∞–ª–µ–µ</button>
        </div>
    </div>
  </div>

  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <script>
    // --- –ì–õ–û–ë–ê–õ–¨–ù–´–ï –ü–ï–†–ï–ú–ï–ù–ù–´–ï –ò –ö–û–ù–°–¢–ê–ù–¢–´ ---
    const LIE_VIDEO_DATA = {
        'dopros1.mp4': '—Å–µ–ø–∞—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ (—É—Ö–æ–¥) –æ—Ç –≤–æ–ø—Ä–æ—Å–∞',
        'dopros2.mp4': '–ª–µ–≥–∫–æ–µ –Ω–∞—Ö–º—É—Ä–∏–≤–∞–Ω–∏–µ',
        'dopros3.mp4': '–ø–æ–¥–∂–∞—Ç–∏–µ –≥—É–±',
        'dopros4.mp4': '—É—á–∏—â–µ–Ω–Ω–æ–µ –º–æ—Ä–≥–∞–Ω–∏–µ',
        'dopros5.mp4': '–ø–æ–¥–∂–∞—Ç–∏–µ –≥—É–±',
        'dopros6.mp4': '—Å–µ–ø–∞—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ (—É—Ö–æ–¥) –æ—Ç –≤–æ–ø—Ä–æ—Å–∞',
        'dopros7.mp4': '–ª–µ–≥–∫–æ–µ –Ω–∞—Ö–º—É—Ä–∏–≤–∞–Ω–∏–µ',
        'dopros8.mp4': '–ø–æ–¥–∂–∞—Ç–∏–µ –≥—É–±'
    };
    const LIE_OPTIONS = [
        '–ü–æ–¥–∂–∞—Ç–∏–µ –≥—É–±', '–£—á–∏—â–µ–Ω–Ω–æ–µ –º–æ—Ä–≥–∞–Ω–∏–µ', '–õ–µ–≥–∫–æ–µ –Ω–∞—Ö–º—É—Ä–∏–≤–∞–Ω–∏–µ', 
        '–õ–µ–≥–∫–æ–µ –ø—Ä–∏–∫–æ—Å–Ω–æ–≤–µ–Ω–∏–µ –ª–∏—Ü–∞ (–ø–æ–¥–±–æ—Ä–æ–¥–∫–∞, –Ω–æ—Å–∞, –≤–µ—Å–∫–∏)', '–ü–æ–∫–∞—á–∏–≤–∞–Ω–∏–µ –≥–æ–ª–æ–≤—ã –≤ —Å—Ç—Ä–æ–Ω—É',
        '–°–µ–ø–∞—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ (—É—Ö–æ–¥) –æ—Ç –≤–æ–ø—Ä–æ—Å–∞', '–û—Ç–±—Ä–∞—Å—ã–≤–∞–Ω–∏–µ –≥–æ–ª–æ–≤—ã –Ω–∞–∑–∞–¥',
        '–î–≤–∏–∂–µ–Ω–∏–µ —Å—É—Å—Ç–∞–≤–∞–º–∏ (–¥–µ—Ä–≥–∞–Ω–∏–µ –Ω–æ–≥–æ–π –∏–ª–∏ –∫–∏—Å—Ç—å—é)',
        '–í–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–µ —Å —Ä—É–∫–∞–º–∏, –≤–µ—â–∞–º–∏ (–∫—Ä—É—Ç–∏—Ç —Ä—É—á–∫—É, —Ç—Ä–æ–≥–∞–µ—Ç –ø–∞–ª—å—Ü—ã –∏ —Ç–¥)',
        '–í—Å–∫–∏–¥—ã–≤–∞–Ω–∏–µ –≤–∑–≥–ª—è–¥–∞ –≤–≤–µ—Ä—Ö', '–ë—ã—Å—Ç—Ä–æ–µ –æ–±–ª–∏–∑—ã–≤–∞–Ω–∏–µ –≥—É–±', '–°–≥–ª–∞—Ç—ã–≤–∞–Ω–∏–µ', '–ù–∞–ø—Ä—è–∂–µ–Ω–∏–µ —á–µ–ª—é—Å—Ç–∏'
    ];

    const EMOTION_VIDEO_DATA = {
        'rf_01_skepticism.mp4': '–°–∫–µ–ø—Ç–∏—Ü–∏–∑–º', 'rf_02_anger.mp4': '–ì–Ω–µ–≤',
        'rf_03_anxiety.mp4': '–¢—Ä–µ–≤–æ–≥–∞', 'rf_04_determination.mp4': '–†–µ—à–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å',
        'rf_04_fear-surprise-denial.mp4': '–°—Ç—Ä–∞—Ö-–£–¥–∏–≤–ª–µ–Ω–∏–µ-–û—Ç—Ä–∏—Ü–∞–Ω–∏–µ', 'rf_05_dominance.mp4': '–î–æ–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ',
        'rf_06_fear-surprise-denial.mp4': '–°—Ç—Ä–∞—Ö-–£–¥–∏–≤–ª–µ–Ω–∏–µ-–û—Ç—Ä–∏—Ü–∞–Ω–∏–µ', 'rf_07_high-self-esteem.mp4': '–í—ã—Å–æ–∫–∞—è —Å–∞–º–æ–æ—Ü–µ–Ω–∫–∞',
        'rf_08_submission.mp4': '–ü–æ–¥—á–∏–Ω–µ–Ω–∏–µ', 'rf_09_surprise.mp4': '–£–¥–∏–≤–ª–µ–Ω–∏–µ',
        'rf_10_contempt.mp4': '–ü—Ä–µ–∑—Ä–µ–Ω–∏–µ', 'rf_11_thoughtfulness.mp4': '–ó–∞–¥—É–º—á–∏–≤–æ—Å—Ç—å',
        'rf_12_skepticism.mp4': '–°–∫–µ–ø—Ç–∏—Ü–∏–∑–º', 'rf_13_anger.mp4': '–ì–Ω–µ–≤', 'rf_14_anxiety.mp4': '–¢—Ä–µ–≤–æ–≥–∞',
        'rf_15_determination.mp4': '–†–µ—à–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å', 'rf_16_dominance.mp4': '–î–æ–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ',
        'rf_17_fear.mp4': '–°—Ç—Ä–∞—Ö', 'rf_18_high-self-esteem.mp4': '–í—ã—Å–æ–∫–∞—è —Å–∞–º–æ–æ—Ü–µ–Ω–∫–∞',
        'rf_19_contempt.mp4': '–ü—Ä–µ–∑—Ä–µ–Ω–∏–µ', 'rf_19_submission.mp4': '–ü–æ–¥—á–∏–Ω–µ–Ω–∏–µ',
        'rf_20_surprise.mp4': '–£–¥–∏–≤–ª–µ–Ω–∏–µ'
    };
    const EMOTION_OPTIONS = [
        '–°–∫–µ–ø—Ç–∏—Ü–∏–∑–º', '–ì–Ω–µ–≤', '–¢—Ä–µ–≤–æ–≥–∞', '–†–µ—à–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å', '–°—Ç—Ä–∞—Ö-–£–¥–∏–≤–ª–µ–Ω–∏–µ-–û—Ç—Ä–∏—Ü–∞–Ω–∏–µ', '–î–æ–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ',
        '–í—ã—Å–æ–∫–∞—è —Å–∞–º–æ–æ—Ü–µ–Ω–∫–∞', '–ü–æ–¥—á–∏–Ω–µ–Ω–∏–µ', '–£–¥–∏–≤–ª–µ–Ω–∏–µ', '–ü—Ä–µ–∑—Ä–µ–Ω–∏–µ', '–ó–∞–¥—É–º—á–∏–≤–æ—Å—Ç—å', '–°—Ç—Ä–∞—Ö'
    ];
    
    // –≠—Ç–∞–ø 3: –ü–æ–π–º–∞–π —Å–∏–≥–Ω–∞–ª
    const SIGNALS = {
      self_soothe: { name: '–°–∞–º–æ—É—Å–ø–æ–∫–æ–µ–Ω–∏–µ', prompt: '–ß—Ç–æ —ç—Ç–æ –±—ã–ª–æ?', options: ['–°–∞–º–æ—É—Å–ø–æ–∫–æ–µ–Ω–∏–µ', '–ë–∞—Ä—å–µ—Ä', '–î–æ–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ'] },
      barrier: { name: '–ë–∞—Ä—å–µ—Ä', prompt: '–ß—Ç–æ —ç—Ç–æ –±—ã–ª–æ?', options: ['–°–∞–º–æ—É—Å–ø–æ–∫–æ–µ–Ω–∏–µ', '–ë–∞—Ä—å–µ—Ä', '–î–æ–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ'] },
      dominance: { name: '–î–æ–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ', prompt: '–ß—Ç–æ —ç—Ç–æ –±—ã–ª–æ?', options: ['–°–∞–º–æ—É—Å–ø–æ–∫–æ–µ–Ω–∏–µ', '–ë–∞—Ä—å–µ—Ä', '–î–æ–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ'] }
    };

    // –≠—Ç–∞–ø 4: –°–æ–±–µ—Ä–∏ –ª–∏—Ü–æ
    const FACE_BUILD_TARGETS = {
        joy: { name: '–£–º–µ—Ä–µ–Ω–Ω–∞—è —Ä–∞–¥–æ—Å—Ç—å', vector: { brows: -0.2, eyes: 0.1, mouth: 0.8 } },
        anger: { name: '–õ–µ–≥–∫–æ–µ —Ä–∞–∑–¥—Ä–∞–∂–µ–Ω–∏–µ', vector: { brows: 0.7, eyes: -0.4, mouth: -0.6 } },
        surprise: { name: '–£–¥–∏–≤–ª–µ–Ω–∏–µ', vector: { brows: 0.8, eyes: 0.8, mouth: 0.3 } },
        sadness: { name: '–ì—Ä—É—Å—Ç—å', vector: { brows: 0.2, eyes: -0.5, mouth: -0.7} }
    };
    
    // –≠—Ç–∞–ø 5: –ö–æ–º–ø–∞—Å –¥–∏—Å—Ç–∞–Ω—Ü–∏–∏
    const PROXEMICS_SCENARIOS = [
        { id: 'colleague', text: '–ö–æ–ª–ª–µ–≥–∞, –∫–æ—Ç–æ—Ä–æ–≥–æ –∑–Ω–∞–µ—à—å —à–∞–ø–æ—á–Ω–æ, —Ö–æ—á–µ—Ç —Å–ø—Ä–æ—Å–∏—Ç—å —Å–æ–≤–µ—Ç', zone: 'social', angle: 30 },
        { id: 'friend', text: '–ë–ª–∏–∑–∫–∏–π –¥—Ä—É–≥, —Ç–∏—Ö–∏–π —Ä–∞–∑–≥–æ–≤–æ—Ä', zone: 'personal', angle: 15 },
        { id: 'stranger', text: '–ù–µ–∑–Ω–∞–∫–æ–º–µ—Ü –Ω–∞ –æ—Å—Ç–∞–Ω–æ–≤–∫–µ', zone: 'public', angle: 120 }
    ];

    const SIGNAL_ANIMATIONS = {
        idle: {
            torso: "M 100 60 L 100 160",
            left_arm: "M 100 80 L 60 140 L 40 200",
            right_arm: "M 100 80 L 140 140 L 160 200"
        },
        self_soothe: [ // —Ä—É–∫–∞ –∫ —à–µ–µ
            { t: 0, d: "M 100 80 L 140 140 L 160 200" }, // start
            { t: 0.3, d: "M 100 80 L 120 100 L 110 70" }, // lift
            { t: 0.6, d: "M 100 80 L 110 80 L 100 60" }, // touch neck
            { t: 1, d: "M 100 80 L 140 140 L 160 200" } // return
        ],
        barrier: [ // —Å–∫—Ä–µ—â–∏–≤–∞–Ω–∏–µ —Ä—É–∫
            { t: 0, left: "M 100 80 L 60 140 L 40 200", right: "M 100 80 L 140 140 L 160 200" },
            { t: 0.5, left: "M 100 80 L 80 120 L 120 120", right: "M 100 80 L 120 120 L 80 120" },
            { t: 1, left: "M 100 80 L 60 140 L 40 200", right: "M 100 80 L 140 140 L 160 200" }
        ],
        dominance: [ // —Ä–∞—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–ª–µ—á
             { t: 0, torso: "M 100 60 L 100 160", left: "M 100 80 L 60 140 L 40 200", right: "M 100 80 L 140 140 L 160 200" },
             { t: 0.5, torso: "M 100 55 L 100 165", left: "M 100 80 L 55 145 L 35 205", right: "M 100 80 L 145 145 L 165 205" },
             { t: 1, torso: "M 100 60 L 100 160", left: "M 100 80 L 60 140 L 40 200", right: "M 100 80 L 140 140 L 160 200" }
        ]
    };

    let gameState = {
        currentPhase: 1,
        lieAttempts: 0,
        emotionAttempts: 0,
        acquiredBadges: new Set(),
        signalGame: {
            running: false,
            timerId: null,
            animationFrameId: null,
            startTime: 0,
            duration: 30000,
            activeSignal: null,
            score: 0,
            misses: 0,
            detectionWindowMs: 700,
            signalsQueue: [],
        }
    };

    // --- –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø ---
    document.addEventListener('DOMContentLoaded', init);

    function init() {
        setupEventListeners();
        loadPhase(gameState.currentPhase);
        document.getElementById('resultModalButton').addEventListener('click', () => {
        const modal = document.getElementById('resultModal');
        if (modal.callback) {
            modal.callback();
        }
        modal.classList.remove('show');
      });
    }

    function setupEventListeners() {
        const lieVideo = document.getElementById('lieVideoPlayer');
        const liePlayBtn = document.getElementById('liePlayBtn');
        const lieProgressFill = document.getElementById('lieProgressFill');

        liePlayBtn.addEventListener('click', () => {
            if (lieVideo.paused) {
                lieVideo.play();
                liePlayBtn.textContent = '‚è∏Ô∏è';
            } else {
                lieVideo.pause();
                liePlayBtn.textContent = '‚ñ∂Ô∏è';
            }
        });

        lieVideo.addEventListener('timeupdate', () => {
            const progress = (lieVideo.currentTime / lieVideo.duration) * 100;
            lieProgressFill.style.width = `${progress}%`;
        });

        lieVideo.addEventListener('ended', () => {
            liePlayBtn.textContent = '‚ñ∂Ô∏è';
        });
        
        document.getElementById('mannequinContainer').addEventListener('click', handleMannequinTap);
        document.getElementById('evaluateFaceBtn').addEventListener('click', handleFaceEvaluation);
        document.getElementById('checkDistanceBtn').addEventListener('click', handleDistanceCheck);
    }
    
    // --- –£–ü–†–ê–í–õ–ï–ù–ò–ï –§–ê–ó–ê–ú–ò ---
    function loadPhase(phase) {
        document.getElementById('lie-detection-phase').style.display = 'none';
        document.getElementById('emotion-detection-phase').style.display = 'none';
        document.getElementById('signal-catch-phase').style.display = 'none';
        document.getElementById('face-build-phase').style.display = 'none';
        document.getElementById('distance-compass-phase').style.display = 'none';
        
        updatePhaseIndicator();

        switch(phase) {
            case 1: loadLiePhase(); break;
            case 2: loadEmotionPhase(); break;
            case 3: loadSignalCatchPhase(); break;
            case 4: loadFaceBuildPhase(); break;
            case 5: loadDistanceCompassPhase(); break;
            default: completeQuest();
        }
    }

    function nextPhase() { gameState.currentPhase++; loadPhase(gameState.currentPhase); }

    // --- –§–ê–ó–ê 1: –õ–û–ñ–¨ ---
    function loadLiePhase() {
        document.getElementById('lie-detection-phase').style.display = 'block';

        const videoFiles = Object.keys(LIE_VIDEO_DATA);
        const currentVideoFile = videoFiles[Math.floor(Math.random() * videoFiles.length)];
        
        const video = document.getElementById('lieVideoPlayer');
        setVideoSource(video, `../video/${currentVideoFile}`);
        video.dataset.correctAnswer = LIE_VIDEO_DATA[currentVideoFile];
        
        gameState.lieAttempts = 0;
        updateAttemptsDisplay('lie');
        createLieOptions();
    }

    function createLieOptions() {
        const video = document.getElementById('lieVideoPlayer');
        const correctAnswer = video.dataset.correctAnswer;
        const options = new Set([correctAnswer]);

        while (options.size < 5) {
            const randomOption = LIE_OPTIONS[Math.floor(Math.random() * LIE_OPTIONS.length)];
            options.add(randomOption);
        }
        
        const shuffledOptions = Array.from(options).sort(() => Math.random() - 0.5);
        
        const container = document.getElementById('lieOptions');
        container.innerHTML = '';
        
        shuffledOptions.forEach(optionText => {
            const button = document.createElement('button');
            button.className = 'answer-option';
            button.textContent = optionText;
            button.onclick = () => handleLieAnswer(optionText, button);
            container.appendChild(button);
        });
    }

    function handleLieAnswer(answer, button) {
        const video = document.getElementById('lieVideoPlayer');
        const correctAnswer = video.dataset.correctAnswer;
        const allButtons = document.querySelectorAll('#lieOptions .answer-option');
        allButtons.forEach(btn => btn.disabled = true);

        if (answer === correctAnswer) {
            button.classList.add('correct');
            hapticFeedback('light');
            setTimeout(nextPhase, 2000);
        } else {
            button.classList.add('incorrect');
            hapticFeedback('error');
            gameState.lieAttempts++;
            updateAttemptsDisplay('lie');
            
            // –ü–æ–∫–∞–∑–∞—Ç—å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç
            allButtons.forEach(btn => {
                if (btn.textContent === correctAnswer) {
                    btn.classList.add('correct');
                }
            });

            if (gameState.lieAttempts >= 3) {
                setTimeout(loadLiePhase, 2000); // –ù–æ–≤–æ–µ –≤–∏–¥–µ–æ –ø–æ—Å–ª–µ 3 –ø—Ä–æ–º–∞—Ö–æ–≤
            } else {
                 setTimeout(() => { // –ù–æ–≤—ã–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã –¥–ª—è —Ç–æ–≥–æ –∂–µ –≤–∏–¥–µ–æ
                    allButtons.forEach(btn => {
                        btn.disabled = false;
                        btn.classList.remove('correct', 'incorrect');
                    });
                    createLieOptions();
                }, 2000);
            }
        }
    }

    // --- –§–ê–ó–ê 2: –≠–ú–û–¶–ò–ò ---
    function loadEmotionPhase() {
        document.getElementById('emotion-detection-phase').style.display = 'block';
        
        const videoFiles = Object.keys(EMOTION_VIDEO_DATA);
        const currentVideoFile = videoFiles[Math.floor(Math.random() * videoFiles.length)];
        
        const video = document.getElementById('emotionVideoPlayer');
        setVideoSource(video, `../assets/videos/${currentVideoFile}`);
        video.dataset.correctAnswer = EMOTION_VIDEO_DATA[currentVideoFile];
        video.play().catch(e => {});

        gameState.emotionAttempts = 0;
        updateAttemptsDisplay('emotion');
        createEmotionOptions();
    }
    
    function createEmotionOptions() {
        const video = document.getElementById('emotionVideoPlayer');
        const correctAnswer = video.dataset.correctAnswer;
        const options = new Set([correctAnswer]);

        while (options.size < 4) {
            const randomOption = EMOTION_OPTIONS[Math.floor(Math.random() * EMOTION_OPTIONS.length)];
            options.add(randomOption);
        }

        const shuffledOptions = Array.from(options).sort(() => Math.random() - 0.5);
        
        const container = document.getElementById('emotionOptions');
        container.innerHTML = '';
        
        shuffledOptions.forEach(optionText => {
            const button = document.createElement('button');
            button.className = 'answer-option';
            button.textContent = optionText;
            button.onclick = () => handleEmotionAnswer(optionText, button);
            container.appendChild(button);
        });
    }

    function handleEmotionAnswer(answer, button) {
        const video = document.getElementById('emotionVideoPlayer');
        const correctAnswer = video.dataset.correctAnswer;
        const allButtons = document.querySelectorAll('#emotionOptions .answer-option');
        allButtons.forEach(btn => btn.disabled = true);

        if (answer === correctAnswer) {
            button.classList.add('correct');
            hapticFeedback('light');
            setTimeout(nextPhase, 2000);
        } else {
            button.classList.add('incorrect');
            hapticFeedback('error');
            gameState.emotionAttempts++;
            updateAttemptsDisplay('emotion');

            allButtons.forEach(btn => {
                if (btn.textContent === correctAnswer) {
                    btn.classList.add('correct');
                }
            });

            if (gameState.emotionAttempts >= 3) {
                setTimeout(loadEmotionPhase, 2000);
            } else {
                setTimeout(() => {
                    allButtons.forEach(btn => {
                        btn.disabled = false;
                        btn.classList.remove('correct', 'incorrect');
                    });
                    createEmotionOptions();
                }, 2000);
            }
        }
    }

    // --- –§–ê–ó–ê 3: –ü–û–ô–ú–ê–ô –°–ò–ì–ù–ê–õ ---
    function loadSignalCatchPhase() {
      document.getElementById('signal-catch-phase').style.display = 'flex';
      startSignalGame();
    }

    function startSignalGame() {
      let game = gameState.signalGame;
      game.running = true;
      game.startTime = Date.now();
      game.score = 0;
      
      // TODO: –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –æ—á–µ—Ä–µ–¥—å —Å–∏–≥–Ω–∞–ª–æ–≤
      generateSignalQueue();
      
      const timerFill = document.querySelector('#signal-catch-phase .signal-timer-fill');
      timerFill.style.transition = 'none';
      timerFill.style.width = '100%';
      
      setTimeout(() => {
          timerFill.style.transition = `width ${game.duration / 1000}s linear`;
          timerFill.style.width = '0%';
      }, 100);

      // –ó–∞–ø—É—Å–∫–∞–µ–º –∞–Ω–∏–º–∞—Ü–∏—é
      animateMannequin();
    }

    function generateSignalQueue() {
      const totalDuration = gameState.signalGame.duration; // ms
      const signals = ['self_soothe','barrier','dominance'];
      const count = 9; // 8-10
      const baseInterval = Math.floor(totalDuration / (count + 1));
      const queue = [];

      for (let i = 1; i <= count; i++) {
        const type = signals[Math.floor(Math.random() * signals.length)];
        const jitter = Math.floor((Math.random() - 0.5) * baseInterval * 0.6);
        queue.push({ type, startTime: i * baseInterval + jitter, duration: 700 });
      }
      // Add 1-2 distractors
      const distractors = Math.random() < 0.5 ? 1 : 2;
      for (let i = 0; i < distractors; i++) {
        const idx = Math.floor(Math.random() * count);
        queue.splice(idx, 0, { type: 'distractor', startTime: (idx+1) * baseInterval + Math.floor((Math.random()-0.5)*baseInterval*0.4), duration: 400 });
      }
      // Sort by startTime and assign to state
      queue.sort((a,b) => a.startTime - b.startTime);
      gameState.signalGame.signalsQueue = queue;
    }

    function animateMannequin() {
        if (!gameState.signalGame.running) return;

        const gameTime = Date.now() - gameState.signalGame.startTime;

        // Idle animation
        const idleSway = Math.sin(gameTime / 600) * 2;
        const man = document.getElementById('manGroup');
        if (man) {
          man.style.transformBox = 'fill-box';
          man.style.transformOrigin = '50% 50%';
          man.style.transform = `translateY(${idleSway}px)`;
        }

        // Check for signal to start
        const nextSignal = gameState.signalGame.signalsQueue[0];
        if (nextSignal && gameTime >= nextSignal.startTime && !gameState.signalGame.activeSignal) {
            gameState.signalGame.activeSignal = gameState.signalGame.signalsQueue.shift();
            gameState.signalGame.activeSignal.animationStart = Date.now();
        }

        // Animate active signal
        if (gameState.signalGame.activeSignal) {
            const signal = gameState.signalGame.activeSignal;
            const signalTime = Date.now() - signal.animationStart;
            const progress = Math.min(signalTime / signal.duration, 1);

            const animationData = SIGNAL_ANIMATIONS[signal.type];
            
            // This is a simplified interpolation. A real implementation would parse and interpolate path points.
            if (signal.type === 'self_soothe') {
                const currentFrame = animationData.find((frame, i) => progress >= frame.t && (animationData[i+1] ? progress < animationData[i+1].t : true));
                document.getElementById('right_arm').setAttribute('d', currentFrame.d);
            } else if (signal.type === 'barrier') {
                const currentFrame = animationData.find((frame, i) => progress >= frame.t && (animationData[i+1] ? progress < animationData[i+1].t : true));
                document.getElementById('left_arm').setAttribute('d', currentFrame.left);
                document.getElementById('right_arm').setAttribute('d', currentFrame.right);
            } else if (signal.type === 'dominance') {
                const currentFrame = animationData.find((frame, i) => progress >= frame.t && (animationData[i+1] ? progress < animationData[i+1].t : true));
                document.getElementById('torso').setAttribute('d', currentFrame.torso);
                document.getElementById('left_arm').setAttribute('d', currentFrame.left);
                document.getElementById('right_arm').setAttribute('d', currentFrame.right);
            }

            if (progress >= 1) {
                gameState.signalGame.activeSignal = null;
                resetMannequinPose();
            }
        }

        requestAnimationFrame(animateMannequin);
    }

    function resetMannequinPose() {
        document.getElementById('torso').setAttribute('d', SIGNAL_ANIMATIONS.idle.torso);
        document.getElementById('left_arm').setAttribute('d', SIGNAL_ANIMATIONS.idle.left_arm);
        document.getElementById('right_arm').setAttribute('d', SIGNAL_ANIMATIONS.idle.right_arm);
    }

    function handleMannequinTap() {
        if (!gameState.signalGame.running) return;

        const tapTime = Date.now();
        const signal = gameState.signalGame.activeSignal;
        
        if (signal) {
            const timeSinceSignalStart = tapTime - signal.animationStart;
            if (timeSinceSignalStart > 100 && timeSinceSignalStart < gameState.signalGame.detectionWindowMs + 100) { // a small buffer
                hapticFeedback('light');
                
                // Pause game
                cancelAnimationFrame(gameState.signalGame.animationFrameId);
                clearTimeout(gameState.signalGame.timerId);

                const signalData = SIGNALS[signal.type];
                showChoiceModal(
                    '–ß—Ç–æ —ç—Ç–æ –±—ã–ª–æ?',
                    '–ö–ª–∞—Å—Å–∏—Ñ–∏—Ü–∏—Ä—É–π —É–≤–∏–¥–µ–Ω–Ω—ã–π —Å–∏–≥–Ω–∞–ª.',
                    signalData.options,
                    (choice) => {
                        if (choice === signalData.name) {
                            gameState.signalGame.score += 1; // Bonus point
                            showPhaseResult("–ü—Ä–∞–≤–∏–ª—å–Ω–æ!", `+1 –æ—á–∫–æ –∑–∞ –≤–µ—Ä–Ω—É—é –∫–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ü–∏—é.`, resumeSignalGame, true);
                        } else {
                            showPhaseResult("–û—à–∏–±–∫–∞!", `–≠—Ç–æ –±—ã–ª —Å–∏–≥–Ω–∞–ª "${signalData.name}".`, resumeSignalGame, true);
                        }
                    }
                );
                
                // Base score for timing
                const timingAccuracy = Math.abs(timeSinceSignalStart - (signal.duration / 2));
                gameState.signalGame.score += (timingAccuracy <= 200) ? 2 : 1;

                gameState.signalGame.activeSignal = null; // Prevent multi-taps
                resetMannequinPose();
            }
        }
    }

    function resumeSignalGame() {
        if (gameState.currentPhase !== 3) return;
        
        gameState.signalGame.running = true;
        const remainingTime = gameState.signalGame.duration - (Date.now() - gameState.signalGame.startTime);
        if (remainingTime > 0) {
            gameState.signalGame.timerId = setTimeout(endSignalGame, remainingTime);
            gameState.signalGame.animationFrameId = requestAnimationFrame(animateMannequin);
        } else {
            endSignalGame();
        }
    }

    function endSignalGame() {
      gameState.signalGame.running = false;
      clearTimeout(gameState.signalGame.timerId);
      cancelAnimationFrame(gameState.signalGame.animationFrameId);
      // console.log(`Signal game ended. Score: ${signalGame.score}`);
      
      gameState.acquiredBadges.add('–ù–∞–±–ª—é–¥–∞—Ç–µ–ª—å');
      // TODO: –ü–æ–∫–∞–∑–∞—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –∏ –∫–Ω–æ–ø–∫—É "–î–∞–ª–µ–µ"
      nextPhase();
    }

    // TODO: –ó–∞–≥—Ä—É–∑–∫–∞ —Ñ–∞–∑—ã 4: –°–æ–±–µ—Ä–∏ –ª–∏—Ü–æ
    function loadFaceBuildPhase() {
        document.getElementById('face-build-phase').style.display = 'block';
        
        const targets = Object.keys(FACE_BUILD_TARGETS);
        const currentTargetKey = targets[Math.floor(Math.random() * targets.length)];
        const currentTarget = FACE_BUILD_TARGETS[currentTargetKey];
        
        document.getElementById('faceBuildTarget').textContent = `–ó–∞–¥–∞–Ω–∏–µ: ${currentTarget.name}`;
        document.getElementById('faceBuildSvg').dataset.targetKey = currentTargetKey;
        
        // –°–±—Ä–æ—Å –∏ –ø—Ä–∏–≤—è–∑–∫–∞ —Å–ª–∞–π–¥–µ—Ä–æ–≤
        ['browsSlider', 'eyesSlider', 'mouthSlider'].forEach(id => {
            const slider = document.getElementById(id);
            slider.value = 0;
            slider.addEventListener('input', updateFaceSvg);
        });
        updateFaceSvg();
    }

    function updateFaceSvg() {
        const brows = parseFloat(document.getElementById('browsSlider').value); // -1 to 1
        const eyes = parseFloat(document.getElementById('eyesSlider').value);   // -1 to 1
        const mouth = parseFloat(document.getElementById('mouthSlider').value); // -1 to 1
        
        const leftEyebrow = document.getElementById('leftEyebrow');
        const rightEyebrow = document.getElementById('rightEyebrow');
        const leftEye = document.getElementById('leftEye');
        const rightEye = document.getElementById('rightEye');
        const mouthPath = document.getElementById('mouth');

        // –ë—Ä–æ–≤–∏: –Ω–∞–∫–ª–æ–Ω
        leftEyebrow.setAttribute('d', `M 50 ${50 - brows*10} Q 80 ${40 - brows * 10}, 110 ${50 + brows * 10}`);
        rightEyebrow.setAttribute('d', `M 110 ${50 + brows * 10} Q 140 ${40 - brows * 10}, 170 ${50 - brows*10}`);
        
        // –ì–ª–∞–∑–∞: –æ—Ç–∫—Ä—ã—Ç–æ—Å—Ç—å (–∏–∑–º–µ–Ω–µ–Ω–∏–µ –∫—Ä–∏–≤–∏–∑–Ω—ã –≤–µ—Ä—Ö–Ω–µ–≥–æ –≤–µ–∫–∞)
        leftEye.setAttribute('d', `M 60 70 Q 80 ${70 - 15 * eyes}, 100 70`);
        rightEye.setAttribute('d', `M 120 70 Q 140 ${70 - 15 * eyes}, 160 70`);
        
        // –†–æ—Ç: —É–ª—ã–±–∫–∞/—Ö–º—É—Ä–æ—Å—Ç—å
        mouthPath.setAttribute('d', `M 70 140 Q 100 ${140 + 20 * mouth}, 130 140`);
    }
    
    // TODO: –ó–∞–≥—Ä—É–∑–∫–∞ —Ñ–∞–∑—ã 5: –ö–æ–º–ø–∞—Å –¥–∏—Å—Ç–∞–Ω—Ü–∏–∏
    function loadDistanceCompassPhase() {
        document.getElementById('distance-compass-phase').style.display = 'block';
        // –ó–¥–µ—Å—å –±—É–¥–µ—Ç –ª–æ–≥–∏–∫–∞ –¥–ª—è 5 —ç—Ç–∞–ø–∞
        setTimeout(nextPhase, 3000); // –í—Ä–µ–º–µ–Ω–Ω–æ –¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏
    }
    
    function handleDistanceCheck() {
        // –ó–¥–µ—Å—å –±—É–¥–µ—Ç –ª–æ–≥–∏–∫–∞ –¥–ª—è 5 —ç—Ç–∞–ø–∞
        // –ù–∞–ø—Ä–∏–º–µ—Ä, –ø–æ–ª—É—á–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–∏ –∞–≤–∞—Ç–∞—Ä–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        const userAvatar = document.getElementById('userAvatar');
        const userAvatarRect = userAvatar.getBoundingClientRect();
        const userAvatarX = userAvatarRect.left + userAvatarRect.width / 2;
        const userAvatarY = userAvatarRect.top + userAvatarRect.height / 2;

        // –ü–æ–ª—É—á–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–∏ NPC –∞–≤–∞—Ç–∞—Ä–∞
        const npcAvatar = document.getElementById('npcAvatar');
        const npcAvatarRect = npcAvatar.getBoundingClientRect();
        const npcAvatarX = npcAvatarRect.left + npcAvatarRect.width / 2;
        const npcAvatarY = npcAvatarRect.top + npcAvatarRect.height / 2;

        // –í—ã—á–∏—Å–ª–µ–Ω–∏–µ —É–≥–ª–æ–≤
        const angle = Math.atan2(npcAvatarY - userAvatarY, npcAvatarX - userAvatarX) * (180 / Math.PI);
        const distance = Math.sqrt(Math.pow(npcAvatarX - userAvatarX, 2) + Math.pow(npcAvatarY - userAvatarY, 2));

        // –°—Ä–∞–≤–Ω–µ–Ω–∏–µ —Å —Ü–µ–ª–µ–≤—ã–º —É–≥–ª–æ–º –∏ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ–º
        const scenario = PROXEMICS_SCENARIOS[Math.floor(Math.random() * PROXEMICS_SCENARIOS.length)];
        const targetAngle = scenario.angle;
        const targetDistance = scenario.zone === 'personal' ? 100 : scenario.zone === 'social' ? 200 : 300; // –ü—Ä–∏–º–µ—Ä–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è

        const angleDiff = Math.abs(angle - targetAngle);
        const distanceDiff = Math.abs(distance - targetDistance);

        let score = 0;
        if (angleDiff < 10 && distanceDiff < 50) { // –ü—Ä–∏–º–µ—Ä–Ω—ã–µ –ø–æ—Ä–æ–≥–∏
            score = 100;
        } else if (angleDiff < 20 && distanceDiff < 100) {
            score = 70;
        } else if (angleDiff < 30 && distanceDiff < 150) {
            score = 40;
        }

        gameState.acquiredBadges.add('–ù–∞–≤–∏–≥–∞—Ç–æ—Ä –¥–∏—Å—Ç–∞–Ω—Ü–∏–∏');
        showPhaseResult("–î–∏—Å—Ç–∞–Ω—Ü–∏—è –æ—Ü–µ–Ω–µ–Ω–∞!", `–í–∞—à —Ä–µ–∑—É–ª—å—Ç–∞—Ç: ${Math.round(score)}%`, nextPhase);
    }

    // --- –õ–û–ì–ò–ö–ê –û–¢–í–ï–¢–û–í ---

    // –°–æ–∑–¥–∞–Ω–∏–µ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ –æ—Ç–≤–µ—Ç–æ–≤ –¥–ª—è –ª–∂–∏
    function createLieOptions() {
      const video = document.getElementById('lieVideoPlayer');
      const correctAnswer = video.dataset.correctAnswer;
      const options = new Set([correctAnswer]);

      while (options.size < 5) {
        const randomOption = LIE_OPTIONS[Math.floor(Math.random() * LIE_OPTIONS.length)];
        options.add(randomOption);
      }
      
      const shuffledOptions = Array.from(options).sort(() => Math.random() - 0.5);
      
      const container = document.getElementById('lieOptions');
      container.innerHTML = '';
      
      shuffledOptions.forEach(optionText => {
        const button = document.createElement('button');
        button.className = 'answer-option';
        button.textContent = optionText;
        button.onclick = () => handleLieAnswer(optionText, button);
        container.appendChild(button);
      });
    }

    // –°–æ–∑–¥–∞–Ω–∏–µ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ –æ—Ç–≤–µ—Ç–æ–≤ –¥–ª—è —ç–º–æ—Ü–∏–π
    function createEmotionOptions() {
      const video = document.getElementById('emotionVideoPlayer');
      const correctAnswer = video.dataset.correctAnswer;
      const options = new Set([correctAnswer]);

      while (options.size < 4) {
        const randomOption = EMOTION_OPTIONS[Math.floor(Math.random() * EMOTION_OPTIONS.length)];
        options.add(randomOption);
      }
      
      const shuffledOptions = Array.from(options).sort(() => Math.random() - 0.5);
      
      const container = document.getElementById('emotionOptions');
      container.innerHTML = '';
      
      shuffledOptions.forEach(optionText => {
        const button = document.createElement('button');
        button.className = 'answer-option';
        button.textContent = optionText;
        button.onclick = () => handleEmotionAnswer(optionText, button);
        container.appendChild(button);
      });
    }

    // –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—Ç–≤–µ—Ç–∞ –Ω–∞ –ª–æ–∂—å
    function handleLieAnswer(answer, button) {
      const video = document.getElementById('lieVideoPlayer');
      const correctAnswer = video.dataset.correctAnswer;
      const allButtons = document.querySelectorAll('#lieOptions .answer-option');
      allButtons.forEach(btn => btn.disabled = true);

      if (answer === correctAnswer) {
        button.classList.add('correct');
        hapticFeedback('light');
        setTimeout(nextPhase, 2000);
      } else {
        button.classList.add('incorrect');
        hapticFeedback('error');
        gameState.lieAttempts++;
        updateAttemptsDisplay('lie');
        
        // –ü–æ–∫–∞–∑–∞—Ç—å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç
        allButtons.forEach(btn => {
          if (btn.textContent === correctAnswer) {
            btn.classList.add('correct');
          }
        });

        if (gameState.lieAttempts >= 3) {
          setTimeout(loadLiePhase, 2000); // –ù–æ–≤–æ–µ –≤–∏–¥–µ–æ –ø–æ—Å–ª–µ 3 –ø—Ä–æ–º–∞—Ö–æ–≤
        } else {
          setTimeout(() => { // –ù–æ–≤—ã–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã –¥–ª—è —Ç–æ–≥–æ –∂–µ –≤–∏–¥–µ–æ
            allButtons.forEach(btn => {
              btn.disabled = false;
              btn.classList.remove('correct', 'incorrect');
            });
            createLieOptions();
          }, 2000);
        }
      }
    }

    // –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—Ç–≤–µ—Ç–∞ –Ω–∞ —ç–º–æ—Ü–∏–∏
    function handleEmotionAnswer(answer, button) {
      const video = document.getElementById('emotionVideoPlayer');
      const correctAnswer = video.dataset.correctAnswer;
      const allButtons = document.querySelectorAll('#emotionOptions .answer-option');
      allButtons.forEach(btn => btn.disabled = true);

      if (answer === correctAnswer) {
        button.classList.add('correct');
        hapticFeedback('light');
        setTimeout(nextPhase, 2000);
      } else {
        button.classList.add('incorrect');
        hapticFeedback('error');
        gameState.emotionAttempts++;
        updateAttemptsDisplay('emotion');

        allButtons.forEach(btn => {
          if (btn.textContent === correctAnswer) {
            btn.classList.add('correct');
          }
        });

        if (gameState.emotionAttempts >= 3) {
          setTimeout(loadEmotionPhase, 2000);
        } else {
          setTimeout(() => {
            allButtons.forEach(btn => {
              btn.disabled = false;
              btn.classList.remove('correct', 'incorrect');
            });
            createEmotionOptions();
          }, 2000);
        }
      }
    }

    // --- UI –û–ë–ù–û–í–õ–ï–ù–ò–Ø ---

    // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–∞ —Ñ–∞–∑—ã
    function updatePhaseIndicator() {
      const badges = document.querySelectorAll('.phase-badge');
      badges.forEach((badge, index) => {
        if (index + 1 === gameState.currentPhase) {
          badge.classList.add('active');
        } else {
          badge.classList.remove('active');
        }
      });
    }

    // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –ø–æ–ø—ã—Ç–æ–∫
    function updateAttemptsDisplay(phase) {
      const dots = document.querySelectorAll(`#${phase}AttemptsDots .attempt-dot`);
      const attempts = phase === 'lie' ? gameState.lieAttempts : gameState.emotionAttempts;
      
      dots.forEach((dot, index) => {
        if (index < attempts) {
          dot.classList.add('used');
        } else {
          dot.classList.remove('used');
        }
      });
    }

    // --- –ó–ê–í–ï–†–®–ï–ù–ò–ï –ö–í–ï–°–¢–ê ---
    function completeQuest() {
      const modal = document.getElementById('questComplete');
      
      // –î–æ–±–∞–≤–ª—è–µ–º –±–µ–π–¥–∂–∏ –≤ –º–æ–¥–∞–ª—å–Ω–æ–µ –æ–∫–Ω–æ
      const badgesContainer = document.getElementById('reward-badges');
      badgesContainer.innerHTML = '';
      if(gameState.acquiredBadges.size > 0) {
          const title = document.createElement('h4');
          title.textContent = '–ü–æ–ª—É—á–µ–Ω–Ω—ã–µ –Ω–∞–≤—ã–∫–∏:';
          badgesContainer.appendChild(title);
          gameState.acquiredBadges.forEach(badge => {
              const badgeEl = document.createElement('span');
              badgeEl.className = 'signal-hint-badge'; // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç–æ—Ç –∂–µ —Å—Ç–∏–ª—å
              badgeEl.textContent = badge;
              badgesContainer.appendChild(badgeEl);
          });
      }

      modal.classList.add('show');
      
      // –°–æ—Ö—Ä–∞–Ω—è–µ–º –Ω–∞–≥—Ä–∞–¥—ã
      if (window.parent && window.parent.addRewards) {
        window.parent.addRewards(3, 500, 'bodylang', '–Ø–∑—ã–∫ —Ç–µ–ª–∞', 'medium');
      } else {
        // Fallback –Ω–∞ localStorage
        const userId = localStorage.getItem('currentUserId') || 'default';
        const userDataKey = `userData_${userId}`;
        const savedData = localStorage.getItem(userDataKey);
        
        if (savedData) {
          const userData = JSON.parse(savedData);
          userData.mulacoin = (userData.mulacoin || 0) + 3;
          userData.exp = (userData.exp || 0) + 500;
          localStorage.setItem(userDataKey, JSON.stringify(userData));
        }
      }
    }

    // –ó–∞–∫—Ä—ã—Ç–∏–µ –º–æ–¥–∞–ª–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è
    function closeQuestComplete() {
      const modal = document.getElementById('questComplete');
      modal.classList.remove('show');
      window.location.href = '../quests.html';
    }

    // --- –£–¢–ò–õ–ò–¢–´ –ê–ù–ò–ú–ê–¶–ò–ò ---
    function parsePath(d) {
        const points = [];
        const commands = d.split(/(?=[ML])/);
        commands.forEach(command => {
            const type = command.charAt(0);
            const Cords = command.substring(1).trim().split(' ');
            Cords.forEach(c => {
                const [x, y] = c.split(',').map(parseFloat);
                if (!isNaN(x) && !isNaN(y)) {
                    points.push({ x, y });
                }
            });
        });
        return points;
    }
    
    function formatPath(points) {
        return points.map(p => `${p.x},${p.y}`).join(' ');
    }

    function lerp(start, end, t) {
        return start * (1 - t) + end * t;
    }

    function interpolatePath(keyframes, progress, currentPoints = null) {
        if (progress <= 0) return keyframes[0].p1 ? [keyframes[0].p1, keyframes[0].p2, keyframes[0].p3] : currentPoints;
        if (progress >= 1) return keyframes[keyframes.length - 1].p1 ? [keyframes[keyframes.length - 1].p1, keyframes[keyframes.length - 1].p2, keyframes[keyframes.length - 1].p3] : currentPoints;

        const segmentIndex = keyframes.findIndex((kf, i) => 
            progress >= kf.t && (keyframes[i+1] && progress < keyframes[i+1].t)
        );
        
        if (segmentIndex === -1) return currentPoints;

        const startKeyframe = keyframes[segmentIndex];
        const endKeyframe = keyframes[segmentIndex + 1];
        
        const segmentProgress = (progress - startKeyframe.t) / (endKeyframe.t - startKeyframe.t);
        
        // Handle partial keyframes for multi-limb animation
        const basePoints = currentPoints || [startKeyframe.p1, startKeyframe.p2, startKeyframe.p3];
        const interpolatedPoints = basePoints.map((point, i) => {
            const pStart = startKeyframe[`p${i+1}`] || point;
            const pEnd = endKeyframe[`p${i+1}`] || pStart;
            return {
                x: lerp(pStart.x, pEnd.x, segmentProgress),
                y: lerp(pStart.y, pEnd.y, segmentProgress)
            };
        });

        return interpolatedPoints;
    }

    // --- –§–ê–ó–ê 4: –°–û–ë–ï–†–ò –õ–ò–¶–û ---
    function handleFaceEvaluation() {
        const targetKey = document.getElementById('faceBuildSvg').dataset.targetKey;
        const targetVector = FACE_BUILD_TARGETS[targetKey].vector;
        
        const userVector = {
            brows: parseFloat(document.getElementById('browsSlider').value),
            eyes: parseFloat(document.getElementById('eyesSlider').value),
            mouth: parseFloat(document.getElementById('mouthSlider').value)
        };
        
        const similarity = cosineSimilarity(targetVector, userVector);
        const score = Math.max(0, Math.round(similarity * 100));

        gameState.acquiredBadges.add('–°–∫—É–ª—å–ø—Ç–æ—Ä —ç–º–æ—Ü–∏–π');
        showPhaseResult("–õ–∏—Ü–æ –æ—Ü–µ–Ω–µ–Ω–æ!", `–°—Ö–æ–¥—Å—Ç–≤–æ: ${score}%.`, nextPhase);
    }

    // --- –§–ê–ó–ê 5: –ö–û–ú–ü–ê–° –î–ò–°–¢–ê–ù–¶–ò–ò ---
    function handleDistanceCheck() {
        // –ó–¥–µ—Å—å –±—É–¥–µ—Ç –ª–æ–≥–∏–∫–∞ –¥–ª—è 5 —ç—Ç–∞–ø–∞
        // –ù–∞–ø—Ä–∏–º–µ—Ä, –ø–æ–ª—É—á–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–∏ –∞–≤–∞—Ç–∞—Ä–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        const userAvatar = document.getElementById('userAvatar');
        const userAvatarRect = userAvatar.getBoundingClientRect();
        const userAvatarX = userAvatarRect.left + userAvatarRect.width / 2;
        const userAvatarY = userAvatarRect.top + userAvatarRect.height / 2;

        // –ü–æ–ª—É—á–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–∏ NPC –∞–≤–∞—Ç–∞—Ä–∞
        const npcAvatar = document.getElementById('npcAvatar');
        const npcAvatarRect = npcAvatar.getBoundingClientRect();
        const npcAvatarX = npcAvatarRect.left + npcAvatarRect.width / 2;
        const npcAvatarY = npcAvatarRect.top + npcAvatarRect.height / 2;

        // –í—ã—á–∏—Å–ª–µ–Ω–∏–µ —É–≥–ª–æ–≤
        const angle = Math.atan2(npcAvatarY - userAvatarY, npcAvatarX - userAvatarX) * (180 / Math.PI);
        const distance = Math.sqrt(Math.pow(npcAvatarX - userAvatarX, 2) + Math.pow(npcAvatarY - userAvatarY, 2));

        // –°—Ä–∞–≤–Ω–µ–Ω–∏–µ —Å —Ü–µ–ª–µ–≤—ã–º —É–≥–ª–æ–º –∏ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ–º
        const scenario = PROXEMICS_SCENARIOS[Math.floor(Math.random() * PROXEMICS_SCENARIOS.length)];
        const targetAngle = scenario.angle;
        const targetDistance = scenario.zone === 'personal' ? 100 : scenario.zone === 'social' ? 200 : 300; // –ü—Ä–∏–º–µ—Ä–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è

        const angleDiff = Math.abs(angle - targetAngle);
        const distanceDiff = Math.abs(distance - targetDistance);

        let score = 0;
        if (angleDiff < 10 && distanceDiff < 50) { // –ü—Ä–∏–º–µ—Ä–Ω—ã–µ –ø–æ—Ä–æ–≥–∏
            score = 100;
        } else if (angleDiff < 20 && distanceDiff < 100) {
            score = 70;
        } else if (angleDiff < 30 && distanceDiff < 150) {
            score = 40;
        }

        gameState.acquiredBadges.add('–ù–∞–≤–∏–≥–∞—Ç–æ—Ä –¥–∏—Å—Ç–∞–Ω—Ü–∏–∏');
        showPhaseResult("–î–∏—Å—Ç–∞–Ω—Ü–∏—è –æ—Ü–µ–Ω–µ–Ω–∞!", `–í–∞—à —Ä–µ–∑—É–ª—å—Ç–∞—Ç: ${Math.round(score)}%`, nextPhase);
    }

    // --- –£–¢–ò–õ–ò–¢–´ ---
    function cosineSimilarity(vecA, vecB) {
        const keys = Object.keys(vecA);
        let dotProduct = 0;
        let normA = 0;
        let normB = 0;
        for (const key of keys) {
            dotProduct += (vecA[key] || 0) * (vecB[key] || 0);
            normA += (vecA[key] || 0) ** 2;
            normB += (vecB[key] || 0) ** 2;
        }
        normA = Math.sqrt(normA);
        normB = Math.sqrt(normB);
        if (normA === 0 || normB === 0) {
            return 0;
        }
        return dotProduct / (normA * normB);
    }
    
    function makeDraggable(element) {
        let isDragging = false;
        let startX, startY, initialX, initialY;

        const stage = element.parentElement;

        stage.addEventListener('mousedown', dragStart, {passive: false});
        stage.addEventListener('touchstart', dragStart, {passive: false});

        stage.addEventListener('mousemove', drag, {passive: false});
        stage.addEventListener('touchmove', drag, {passive: false});

        stage.addEventListener('mouseup', dragEnd);
        stage.addEventListener('touchend', dragEnd);
        stage.addEventListener('mouseleave', dragEnd);
        
        function dragStart(e) {
            const targetEl = e.target.closest('#userAvatar');
            if (targetEl && targetEl === element) {
                e.preventDefault();
                isDragging = true;
                
                if (e.type === 'touchstart') {
                    startX = e.touches[0].clientX;
                    startY = e.touches[0].clientY;
                } else {
                    startX = e.clientX;
                    startY = e.clientY;
                }

                const computedStyle = window.getComputedStyle(element);
                const transform = computedStyle.getPropertyValue('transform');
                if (transform && transform !== 'none') {
                    const matrix = new DOMMatrix(transform);
                    initialX = matrix.m41;
                    initialY = matrix.m42;
                } else {
                    initialX = 0;
                    initialY = 0;
                }
                
                element.style.cursor = 'grabbing';
            }
        }
        
        function drag(e) {
            if (isDragging) {
                e.preventDefault();
                let currentX, currentY;
                if (e.type === 'touchmove') {
                    currentX = e.touches[0].clientX;
                    currentY = e.touches[0].clientY;
                } else {
                    currentX = e.clientX;
                    currentY = e.clientY;
                }

                const dx = currentX - startX;
                const dy = currentY - startY;
                
                element.style.transform = `translate(${initialX + dx}px, ${initialY + dy}px)`;
            }
        }

        function dragEnd(e) {
            if(isDragging) {
                isDragging = false;
                element.style.cursor = 'grab';
            }
        }
    }
    
    function showChoiceModal(title, text, options, callback) {
        const modal = document.getElementById('resultModal');
        document.getElementById('resultModalTitle').textContent = title;
        document.getElementById('resultModalText').textContent = text;
        
        const choicesContainer = document.getElementById('resultModalChoices');
        choicesContainer.innerHTML = '';
        
        options.forEach(optionText => {
            const button = document.createElement('button');
            button.className = 'result-modal-button';
            button.textContent = optionText;
            button.onclick = () => {
                modal.classList.remove('show');
                callback(optionText);
            };
            choicesContainer.appendChild(button);
        });

        document.getElementById('resultModalButton').style.display = 'none';
        choicesContainer.style.display = 'flex';
        modal.classList.add('show');
    }

    function showPhaseResult(title, text, callback, autoClose = true) {
        const modal = document.getElementById('resultModal');
        document.getElementById('resultModalTitle').textContent = title;
        document.getElementById('resultModalText').textContent = text;
        modal.callback = callback;

        const choicesContainer = document.getElementById('resultModalChoices');
        const nextButton = document.getElementById('resultModalButton');
        
        choicesContainer.style.display = 'none';
        nextButton.style.display = 'block';
        nextButton.onclick = () => {
             modal.classList.remove('show');
             if(callback) callback();
        };

        modal.classList.add('show');
        
        if (autoClose) {
            setTimeout(() => {
                if (modal.classList.contains('show')) {
                    modal.classList.remove('show');
                    if (callback) callback();
                }
            }, 2000);
        } else {
            document.getElementById('resultModalButton').style.display = 'block';
        }
    }

    function hapticFeedback(type) {
        try {
          if (window.Telegram && window.Telegram.WebApp && window.Telegram.WebApp.HapticFeedback) {
            const hf = window.Telegram.WebApp.HapticFeedback;
            if (type === 'error') {
              hf.notificationOccurred && hf.notificationOccurred('error');
            } else if (type === 'light' || type === 'medium' || type === 'heavy') {
              hf.impactOccurred && hf.impactOccurred(type);
            } else {
              hf.impactOccurred && hf.impactOccurred('light');
            }
          }
        } catch (_) {}
    }

    // Utility to reliably set video source and reload
    function setVideoSource(videoEl, srcPath) {
      const source = videoEl.querySelector('source');
      if (source) {
        source.setAttribute('src', srcPath);
      }
      // Set both to maximize compatibility
      videoEl.src = srcPath;
      videoEl.load();
    }
  </script>
</body>
</html>
